import { act, fireEvent, render, screen, waitFor } from "@testing-library/react";
import * as React from "react";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";

import AipDetailView from "./aip-detail-view";
import type { AipHeader, AipStatus } from "../types";
import type { AipRevisionFeedbackCycle } from "@/lib/repos/aip/repo";
import type {
  ExtractionRunRealtimeEvent,
  UseExtractionRunsRealtimeInput,
} from "../hooks/use-extraction-runs-realtime";

const mockReplace = vi.fn();
const mockRefresh = vi.fn();
const mockPush = vi.fn();
let lastDetailsTableProps: {
  scope: "city" | "barangay";
  enablePagination?: boolean;
} | null = null;
let mockProjectsState = {
  loading: false,
  error: null as string | null,
  unresolvedAiCount: 0,
};
let mockSearchParams = new URLSearchParams();
let latestRealtimeArgs: UseExtractionRunsRealtimeInput | null = null;

vi.mock("next/navigation", () => ({
  usePathname: () => "/barangay/aips/aip-001",
  useRouter: () => ({
    replace: mockReplace,
    refresh: mockRefresh,
    push: mockPush,
  }),
  useSearchParams: () => mockSearchParams,
}));

vi.mock("@/components/layout/breadcrumb-nav", () => ({
  BreadcrumbNav: () => <div data-testid="breadcrumb-nav" />,
}));

vi.mock("../components/aip-pdf-container", () => ({
  AipPdfContainer: () => <div data-testid="aip-pdf-container" />,
}));

vi.mock("../components/aip-details-summary", () => ({
  AipDetailsSummary: () => <div data-testid="aip-details-summary" />,
}));

vi.mock("../components/aip-uploader-info", () => ({
  AipUploaderInfo: () => <div data-testid="aip-uploader-info" />,
}));

vi.mock("../components/aip-processing-inline-status", () => ({
  AipProcessingInlineStatus: () => <div data-testid="aip-processing-inline-status" />,
}));

vi.mock("../components/lgu-aip-feedback-thread", () => ({
  LguAipFeedbackThread: () => <div data-testid="lgu-aip-feedback-thread" />,
}));

vi.mock("./aip-details-table", () => ({
  AipDetailsTableView: ({
    onProjectsStateChange,
    scope,
    enablePagination,
  }: {
    onProjectsStateChange?: (state: {
      rows: unknown[];
      loading: boolean;
      error: string | null;
      unresolvedAiCount: number;
    }) => void;
    scope: "city" | "barangay";
    enablePagination?: boolean;
  }) => {
    lastDetailsTableProps = { scope, enablePagination };
    React.useEffect(() => {
      onProjectsStateChange?.({
        rows: [],
        loading: mockProjectsState.loading,
        error: mockProjectsState.error,
        unresolvedAiCount: mockProjectsState.unresolvedAiCount,
      });
    }, [onProjectsStateChange]);
    return <div data-testid="aip-details-table-view" />;
  },
}));

vi.mock("@/features/feedback", () => ({
  CommentThreadsSplitView: () => <div data-testid="comment-threads-split-view" />,
}));

vi.mock("../actions/aip-workflow.actions", () => ({
  submitAipForReviewAction: vi.fn(async () => ({ ok: true, message: "Submitted" })),
  submitCityAipForPublishAction: vi.fn(async () => ({ ok: true, message: "Published" })),
  saveAipRevisionReplyAction: vi.fn(async () => ({ ok: true, message: "Saved" })),
  deleteAipDraftAction: vi.fn(async () => ({ ok: true, message: "Deleted" })),
  cancelAipSubmissionAction: vi.fn(async () => ({ ok: true, message: "Canceled" })),
}));

vi.mock("../hooks/use-extraction-runs-realtime", async () => {
  const actual = await vi.importActual<typeof import("../hooks/use-extraction-runs-realtime")>(
    "../hooks/use-extraction-runs-realtime"
  );
  return {
    ...actual,
    useExtractionRunsRealtime: vi.fn((args: UseExtractionRunsRealtimeInput) => {
      latestRealtimeArgs = args;
    }),
  };
});

function baseAip(status: AipStatus, overrides: Partial<AipHeader> = {}): AipHeader {
  return {
    id: "aip-001",
    scope: "barangay",
    barangayName: "Brgy. Test",
    title: "Annual Investment Program 2026",
    description: "AIP description",
    year: 2026,
    budget: 1000000,
    uploadedAt: "2026-01-01",
    status,
    fileName: "AIP_2026_Test.pdf",
    pdfUrl: "https://example.com/aip.pdf",
    sectors: ["General Sector"],
    uploader: {
      name: "Test User",
      role: "Barangay Official",
      uploadDate: "Jan 1, 2026",
      budgetAllocated: 1000000,
    },
    ...overrides,
  };
}

function revisionCycle(overrides: Partial<AipRevisionFeedbackCycle> = {}): AipRevisionFeedbackCycle {
  return {
    cycleId: "cycle-001",
    reviewerRemark: {
      id: "remark-001",
      body: "Please revise.",
      createdAt: "2026-01-01T08:00:00.000Z",
      authorRole: "reviewer",
      authorName: "Reviewer",
    },
    replies: [],
    ...overrides,
  };
}

describe("AipDetailView sidebar behavior", () => {
  beforeEach(() => {
    lastDetailsTableProps = null;
    mockSearchParams = new URLSearchParams();
    latestRealtimeArgs = null;
    mockProjectsState = {
      loading: false,
      error: null,
      unresolvedAiCount: 0,
    };
    vi.stubGlobal(
      "fetch",
      vi.fn(async () => {
        return new Response(JSON.stringify({ run: null }), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      })
    );
  });

  afterEach(() => {
    vi.unstubAllGlobals();
    vi.clearAllMocks();
  });

  it("shows actionable sidebar for for_revision", async () => {
    render(
      <AipDetailView
        aip={baseAip("for_revision", {
          feedback: "Reviewer feedback is available.",
          revisionFeedbackCycles: [revisionCycle()],
        })}
        scope="barangay"
      />
    );

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(screen.getByText("Official Comment / Justification")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Resubmit" })).toBeInTheDocument();
    expect(screen.getByText("Reviewer Feedback History")).toBeInTheDocument();
    expect(screen.queryByText("Cycle 1 of 1")).not.toBeInTheDocument();
  });

  it("shows read-only notice and hides workflow actions for non-uploader barangay official", async () => {
    render(
      <AipDetailView
        aip={baseAip("for_revision", {
          revisionFeedbackCycles: [revisionCycle()],
          workflowPermissions: {
            canManageBarangayWorkflow: false,
            lockReason: "Only the uploader of this AIP can modify this workflow.",
          },
        })}
        scope="barangay"
      />
    );

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(
      screen.getAllByText("Only the uploader of this AIP can modify this workflow.")
        .length
    ).toBeGreaterThan(0);
    expect(screen.queryByRole("button", { name: "Resubmit" })).not.toBeInTheDocument();
    expect(screen.queryByRole("button", { name: "Save Reply" })).not.toBeInTheDocument();
    expect(screen.queryByRole("button", { name: "Submit for Review" })).not.toBeInTheDocument();
  });

  it("paginates reviewer feedback history by revision cycle", async () => {
    render(
      <AipDetailView
        aip={baseAip("published", {
          revisionFeedbackCycles: [
            revisionCycle({
              cycleId: "cycle-002",
              reviewerRemark: {
                id: "remark-002",
                body: "Latest reviewer remark.",
                createdAt: "2026-01-03T08:00:00.000Z",
                authorRole: "reviewer",
                authorName: "Latest Reviewer",
              },
              replies: [],
            }),
            revisionCycle({
              cycleId: "cycle-001",
              reviewerRemark: {
                id: "remark-001",
                body: "Older reviewer remark.",
                createdAt: "2026-01-01T08:00:00.000Z",
                authorRole: "reviewer",
                authorName: "Older Reviewer",
              },
              replies: [],
            }),
          ],
        })}
        scope="barangay"
      />
    );

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(screen.getByText("Latest reviewer remark.")).toBeInTheDocument();
    expect(screen.queryByText("Older reviewer remark.")).not.toBeInTheDocument();
    expect(screen.getByText("Cycle 1 of 2")).toBeInTheDocument();

    fireEvent.click(screen.getByRole("button", { name: "Next" }));

    expect(screen.queryByText("Latest reviewer remark.")).not.toBeInTheDocument();
    expect(screen.getByText("Older reviewer remark.")).toBeInTheDocument();
    expect(screen.getByText("Cycle 2 of 2")).toBeInTheDocument();

    fireEvent.click(screen.getByRole("button", { name: "Previous" }));

    expect(screen.getByText("Latest reviewer remark.")).toBeInTheDocument();
    expect(screen.queryByText("Older reviewer remark.")).not.toBeInTheDocument();
    expect(screen.getByText("Cycle 1 of 2")).toBeInTheDocument();
  });

  it("shows cancel action sidebar for pending_review", async () => {
    render(
      <AipDetailView
        aip={baseAip("pending_review", {
          revisionFeedbackCycles: [revisionCycle()],
        })}
        scope="barangay"
      />
    );

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(screen.getByText("Official Comment / Justification")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Cancel Submission" })).toBeInTheDocument();
    expect(screen.getByText("Reviewer Feedback History")).toBeInTheDocument();
  });

  it("shows status info sidebar for under_review with no workflow actions", async () => {
    render(
      <AipDetailView
        aip={baseAip("under_review", {
          revisionFeedbackCycles: [revisionCycle()],
        })}
        scope="barangay"
      />
    );

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(screen.getByText("Under Review Status")).toBeInTheDocument();
    expect(screen.queryByText("Official Comment / Justification")).not.toBeInTheDocument();
    expect(screen.queryByRole("button", { name: "Resubmit" })).not.toBeInTheDocument();
    expect(screen.queryByRole("button", { name: "Cancel Submission" })).not.toBeInTheDocument();
    expect(screen.queryByText("Publication Details")).not.toBeInTheDocument();
    expect(screen.getByText("Reviewer Feedback History")).toBeInTheDocument();
  });

  it("shows status info sidebar for published with no workflow actions", async () => {
    render(
      <AipDetailView
        aip={baseAip("published", {
          revisionFeedbackCycles: [revisionCycle()],
          publishedBy: {
            reviewerId: "city-user-001",
            reviewerName: "City Reviewer",
            createdAt: "2026-01-02T08:30:00.000Z",
          },
        })}
        scope="barangay"
      />
    );

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(screen.getByText("Published Status")).toBeInTheDocument();
    expect(screen.queryByText("Official Comment / Justification")).not.toBeInTheDocument();
    expect(screen.queryByRole("button", { name: "Resubmit" })).not.toBeInTheDocument();
    expect(screen.queryByRole("button", { name: "Cancel Submission" })).not.toBeInTheDocument();
    expect(screen.getByText("Publication Details")).toBeInTheDocument();
    expect(screen.getByText(/City Reviewer/)).toBeInTheDocument();
    expect(screen.getByText("Reviewer Feedback History")).toBeInTheDocument();
  });

  it("hides reviewer feedback history for published AIP with no feedback cycles", async () => {
    render(
      <AipDetailView
        aip={baseAip("published", {
          revisionFeedbackCycles: [],
          publishedBy: {
            reviewerId: "city-user-001",
            reviewerName: "City Reviewer",
            createdAt: "2026-01-02T08:30:00.000Z",
          },
        })}
        scope="barangay"
      />
    );

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(screen.getByText("Published Status")).toBeInTheDocument();
    expect(screen.getByText("Publication Details")).toBeInTheDocument();
    expect(screen.queryByText("Reviewer Feedback History")).not.toBeInTheDocument();
  });

  it("shows actionable sidebar for draft with revision history", async () => {
    render(
      <AipDetailView
        aip={baseAip("draft", {
          revisionFeedbackCycles: [revisionCycle()],
        })}
        scope="barangay"
      />
    );

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(screen.getByText("Official Comment / Justification")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Save Reply" })).toBeInTheDocument();
    expect(screen.getByText("Reviewer Feedback History")).toBeInTheDocument();
  });

  it("hides right sidebar for draft without revision history", async () => {
    render(<AipDetailView aip={baseAip("draft")} scope="barangay" />);

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(screen.queryByText("Official Comment / Justification")).not.toBeInTheDocument();
    expect(screen.queryByText("Reviewer Feedback History")).not.toBeInTheDocument();
    expect(screen.queryByText("Draft Status")).not.toBeInTheDocument();
  });

  it("shows city submit and publish CTA for draft", async () => {
    render(<AipDetailView aip={baseAip("draft", { scope: "city" })} scope="city" />);

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(screen.getByRole("button", { name: "Submit & Publish" })).toBeInTheDocument();
    const firstFetchPath = ((global.fetch as unknown as { mock: { calls: unknown[][] } }).mock
      .calls[0]?.[0] ?? "") as string;
    expect(firstFetchPath).toContain("/api/city/aips/");
  });

  it("enables project pagination for both barangay and city detail views", async () => {
    const { rerender } = render(<AipDetailView aip={baseAip("draft")} scope="barangay" />);

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });
    expect(lastDetailsTableProps).toEqual({
      scope: "barangay",
      enablePagination: true,
    });

    rerender(<AipDetailView aip={baseAip("draft", { scope: "city" })} scope="city" />);

    await waitFor(() => {
      expect(lastDetailsTableProps).toEqual({
        scope: "city",
        enablePagination: true,
      });
    });
  });

  it("opens draft delete confirmation and deletes barangay draft", async () => {
    const actions = await import("../actions/aip-workflow.actions");
    const deleteDraftAction = vi.mocked(actions.deleteAipDraftAction);

    render(<AipDetailView aip={baseAip("draft")} scope="barangay" />);

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    fireEvent.click(screen.getByRole("button", { name: "Delete Draft" }));
    expect(screen.getByText("Delete Draft AIP")).toBeInTheDocument();

    fireEvent.click(screen.getByRole("button", { name: "Confirm Delete" }));

    await waitFor(() => {
      expect(deleteDraftAction).toHaveBeenCalledWith({ aipId: "aip-001" });
    });
    await waitFor(() => {
      expect(mockPush).toHaveBeenCalledWith("/barangay/aips");
    });
  });

  it("opens draft delete confirmation and deletes city draft", async () => {
    const actions = await import("../actions/aip-workflow.actions");
    const deleteDraftAction = vi.mocked(actions.deleteAipDraftAction);

    render(<AipDetailView aip={baseAip("draft", { scope: "city" })} scope="city" />);

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    fireEvent.click(screen.getByRole("button", { name: "Delete Draft" }));
    expect(screen.getByText("Delete Draft AIP")).toBeInTheDocument();

    fireEvent.click(screen.getByRole("button", { name: "Confirm Delete" }));

    await waitFor(() => {
      expect(deleteDraftAction).toHaveBeenCalledWith({ aipId: "aip-001" });
    });
    await waitFor(() => {
      expect(mockPush).toHaveBeenCalledWith("/city/aips");
    });
  });

  it("shows city submit and publish CTA for for_revision", async () => {
    render(
      <AipDetailView
        aip={baseAip("for_revision", { scope: "city" })}
        scope="city"
      />
    );

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(screen.getByRole("button", { name: "Submit & Publish" })).toBeInTheDocument();
  });

  it("opens city publish confirmation and submits publish action", async () => {
    const actions = await import("../actions/aip-workflow.actions");
    const publishAction = vi.mocked(actions.submitCityAipForPublishAction);

    render(<AipDetailView aip={baseAip("draft", { scope: "city" })} scope="city" />);

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    fireEvent.click(screen.getByRole("button", { name: "Submit & Publish" }));
    expect(screen.getByText("Publish AIP")).toBeInTheDocument();

    fireEvent.click(screen.getByRole("button", { name: "Confirm & Publish" }));

    await waitFor(() => {
      expect(publishAction).toHaveBeenCalledWith({ aipId: "aip-001" });
    });
  });

  it("shows unresolved AI block message for city submit", async () => {
    mockProjectsState = {
      loading: false,
      error: null,
      unresolvedAiCount: 2,
    };

    render(<AipDetailView aip={baseAip("draft", { scope: "city" })} scope="city" />);

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(
      screen.getByText(
        "2 AI-flagged project(s) still need an official response before submission."
      )
    ).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Submit & Publish" })).toBeDisabled();
  });

  it("tracks run updates via realtime and clears run query after success", async () => {
    mockSearchParams = new URLSearchParams("run=run-001");
    vi.stubGlobal(
      "fetch",
      vi.fn(async (input: RequestInfo | URL) => {
        const url = String(input);
        if (url.includes("/api/barangay/aips/runs/run-001")) {
          return new Response(
            JSON.stringify({
              runId: "run-001",
              aipId: "aip-001",
              stage: "extract",
              status: "running",
              errorMessage: null,
              overallProgressPct: 10,
              stageProgressPct: 25,
              progressMessage: "Extracting from snapshot...",
              progressUpdatedAt: "2026-02-21T00:00:30.000Z",
            }),
            {
              status: 200,
              headers: { "Content-Type": "application/json" },
            }
          );
        }
        return new Response(JSON.stringify({ run: null }), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      })
    );

    render(
      <AipDetailView
        aip={baseAip("draft", {
          summaryText: "Summary already available.",
        })}
        scope="barangay"
      />
    );

    await waitFor(() => {
      expect(latestRealtimeArgs?.enabled).toBe(true);
    });

    await waitFor(() => {
      expect(screen.getByTestId("aip-processing-inline-status")).toBeInTheDocument();
    });

    act(() => {
      latestRealtimeArgs?.onRunEvent?.({
        eventType: "UPDATE",
        run: {
          id: "run-001",
          aip_id: "aip-001",
          stage: "extract",
          status: "running",
          error_message: null,
          overall_progress_pct: 15,
          stage_progress_pct: 35,
          progress_message: "Extracting...",
          progress_updated_at: "2026-02-21T00:01:00.000Z",
        },
      } as ExtractionRunRealtimeEvent);
    });

    await waitFor(() => {
      expect(screen.getByTestId("aip-processing-inline-status")).toBeInTheDocument();
    });

    act(() => {
      latestRealtimeArgs?.onRunEvent?.({
        eventType: "UPDATE",
        run: {
          id: "run-001",
          aip_id: "aip-001",
          stage: "categorize",
          status: "succeeded",
          error_message: null,
          overall_progress_pct: 100,
          stage_progress_pct: 100,
          progress_message: null,
          progress_updated_at: "2026-02-21T00:03:00.000Z",
        },
      } as ExtractionRunRealtimeEvent);
    });

    await waitFor(() => {
      expect(mockReplace).toHaveBeenCalledWith("/barangay/aips/aip-001", {
        scroll: false,
      });
    });
  });

  it("shows a non-blocking notice when realtime status tracking fails", async () => {
    mockSearchParams = new URLSearchParams("run=run-001");
    vi.stubGlobal(
      "fetch",
      vi.fn(async (input: RequestInfo | URL) => {
        const url = String(input);
        if (url.includes("/api/barangay/aips/runs/run-001")) {
          return new Response(
            JSON.stringify({
              runId: "run-001",
              aipId: "aip-001",
              stage: "validate",
              status: "running",
              errorMessage: null,
              overallProgressPct: 62,
              stageProgressPct: 80,
              progressMessage: "Validating snapshot...",
              progressUpdatedAt: "2026-02-21T00:01:00.000Z",
            }),
            {
              status: 200,
              headers: { "Content-Type": "application/json" },
            }
          );
        }
        return new Response(JSON.stringify({ run: null }), {
          status: 200,
          headers: { "Content-Type": "application/json" },
        });
      })
    );

    render(<AipDetailView aip={baseAip("draft")} scope="barangay" />);

    await waitFor(() => {
      expect(latestRealtimeArgs?.enabled).toBe(true);
    });

    await waitFor(() => {
      expect(screen.getByTestId("aip-processing-inline-status")).toBeInTheDocument();
    });

    act(() => {
      latestRealtimeArgs?.onStatusChange?.("CHANNEL_ERROR" as never);
    });

    expect(latestRealtimeArgs?.onSubscribeError).toBeTypeOf("function");
    act(() => {
      latestRealtimeArgs?.onSubscribeError?.(new Error("channel error"));
    });

    expect(latestRealtimeArgs?.onStatusChange).toBeTypeOf("function");
    expect(screen.getByTestId("aip-processing-inline-status")).toBeInTheDocument();
  });

  it("rehydrates run snapshot when realtime reconnects", async () => {
    mockSearchParams = new URLSearchParams("run=run-001");
    const fetchMock = vi.fn(async (input: RequestInfo | URL) => {
      const url = String(input);
      if (url.includes("/api/barangay/aips/runs/run-001")) {
        return new Response(
          JSON.stringify({
            runId: "run-001",
            aipId: "aip-001",
            stage: "summarize",
            status: "running",
            errorMessage: null,
            overallProgressPct: 74,
            stageProgressPct: 40,
            progressMessage: "Reconnect snapshot...",
            progressUpdatedAt: "2026-02-21T00:02:00.000Z",
          }),
          {
            status: 200,
            headers: { "Content-Type": "application/json" },
          }
        );
      }
      return new Response(JSON.stringify({ run: null }), {
        status: 200,
        headers: { "Content-Type": "application/json" },
      });
    });
    vi.stubGlobal("fetch", fetchMock);

    render(<AipDetailView aip={baseAip("draft")} scope="barangay" />);

    await waitFor(() => {
      expect(latestRealtimeArgs?.enabled).toBe(true);
    });

    const callsBeforeReconnect = fetchMock.mock.calls.length;
    act(() => {
      latestRealtimeArgs?.onStatusChange?.("SUBSCRIBED" as never);
    });

    await waitFor(() => {
      expect(fetchMock.mock.calls.length).toBeGreaterThan(callsBeforeReconnect);
    });
  });

  it("shows workflow and citizen feedback containers in feedback tab when published", async () => {
    mockSearchParams = new URLSearchParams("tab=comments&thread=thread-1");
    render(<AipDetailView aip={baseAip("published")} scope="barangay" />);

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(screen.getByText("No workflow feedback history yet.")).toBeInTheDocument();
    expect(screen.getByText("Citizen Feedback")).toBeInTheDocument();
    expect(screen.getByTestId("lgu-aip-feedback-thread")).toBeInTheDocument();
  });

  it("hides citizen feedback container in feedback tab before publish", async () => {
    mockSearchParams = new URLSearchParams("tab=comments");
    render(<AipDetailView aip={baseAip("draft")} scope="barangay" />);

    await waitFor(() => {
      expect(screen.queryByText("Checking extraction status...")).not.toBeInTheDocument();
    });

    expect(screen.getByText("No workflow feedback history yet.")).toBeInTheDocument();
    expect(screen.queryByText("Citizen Feedback")).not.toBeInTheDocument();
    expect(screen.queryByTestId("lgu-aip-feedback-thread")).not.toBeInTheDocument();
  });
});
